{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPS-BoldMT;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\froman\fcharset0 TimesNewRomanPS-BoldItalicMT;
\f3\froman\fcharset0 TimesNewRomanPS-ItalicMT;\f4\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red255\green0\blue0;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgenericrgb\c100000\c0\c0;\csgenericrgb\c0\c0\c0;}
{\info
{\title Exercise 2}
{\author vazhenin}}\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\pardirnatural\partightenfactor0

\f0\b\fs38 \cf0 Exercise 2. Answer Sheet 
\f1\b0 \
\pard\pardeftab720\pardirnatural\partightenfactor0

\fs30 \cf0 \
\
\pard\pardeftab720\pardirnatural\partightenfactor0

\fs24 \cf0 Student's Name: ____Tran Thi Thoa______		Student's ID: ___s1242006____\
\pard\pardeftab720\li720\fi-360\sa120\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\sa120\pardirnatural\qj\partightenfactor0

\f2\i\b \cf0 Problem 1.
\f1\i0\b0  
\f3\i (10 points)
\f1\i0  Consider a priority queue S implemented as a heap. Write a pseudo-code for the 
\f0\b Maximum(S) 
\f1\b0 operation on this priority queue. \
\pard\pardeftab720\li720\fi-360\pardirnatural\qj\partightenfactor0
\cf2 \
def  Maximum(S)\
     // Input: heap S[1..n]\
     // Return the element of S with the largest key\
     return S[1];\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\pardirnatural\qj\partightenfactor0

\f2\i\b \cf0 Problem 2. 
\f3\b0 (20 points)
\f2\b  
\f1\i0\b0 Consider top-down heap construction approach.  \
\
	a). Write a pseudo-code for a 
\f0\b HeapTopDown(A) 
\f1\b0 algorithm using 
\f0\b Max-Heap-Insert (A, key)
\f1\b0  operation\
\pard\pardeftab720\li720\fi-360\pardirnatural\partightenfactor0
\cf2 \
def  Max-Heap-Insert(A, key)\
        //Input: heap A[1..n] and new key.\
        //Output: heap A[1..n+1]\
        A.heap_size = A.heap_size + 1\
        A[A.heap_size] = MAX_NEGATIVE\
        Heap-Increase-Key(A, A.heap_size, key)\
\
def  HeapTopDown(A)\
        //constructs a heap from the elements of a given array by the top-down algorithm\
        //Input: An array A[1..n]\
        //Output: A heap A[1..n]\
       B.length = A.length\
       for i = 1 to B.length\
                B[i] = A[i]\
       end for\
       A.heap_size = 0\
       for i = 1 to B.length\
                 A = Max-Heap-Insert(A,B[i])\
        end for\
\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf3 	b) What is the time complexity of 
\f0\b HeapTopDown(A) 
\f1\b0 algorithm? Why?\
\pard\pardeftab720\li720\fi-360\sa120\pardirnatural\partightenfactor0
\cf2 	\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf2      From the algorithm of the HeapTopDown(A) , we can see that the algorithm has 2 part:\
          + Array B construction which has O(n) time complexity.\
          + The algorithm repeats n times the Max-Heap-Insert(A, key) algorithm, which has the time complexity is 0(log n).\
     Total: O(n) + n O(log n) = O(n log n)\
     Therefore, the time complexity of the HeapTopDown(A) algorithm is O(n log n)\
\
\pard\pardeftab720\pardirnatural\qj\partightenfactor0

\f2\i\b \cf0 Problem 3. 
\f3\b0 (20 points)
\f2\b  
\f1\i0\b0 Illustrate the operation 
\f0\b Heap-Extract-Max
\f1\b0  on a heap A=[15,13,9,5,12,8,7,4,0,6]\
\pard\pardeftab720\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\li720\fi-360\pardirnatural\partightenfactor0
\cf2 The pseudo-code for the Heap-Extract-Max() algorithm is:\
     Def Heap-Extract-Max(A)\
             //Input: heapA[1..n]\
             //Removes and returns the root element\
             max = A[1]\
             A[1] = A[A.heap_size]\
             A.heap_size = A.heap_size - 1\
            MaxHeapify(A,1)\
            return max\
\
The Heap-Extract-Max operations on the heap A:\
\
A = [15,13,9,5,12,8,7,4,0,6]                   //define max = A[1]\
max = 15\
\
\
A = [6,13,9,5,12,8,7,4,0]                       //let A[1] = A[heap_size] \
max = 15                                               //and decrease A.heap_size by 1\
\
\
A =  [13,6,9,5,12,8,7,4,0]                       //call MaxHeapify(A,1)\
max = 15\
\
\
A = [13,12,9,5,6,8,7,4,0]                        //call MaxHeapify(A,2)\
max = 15\
\
\
A = [13,12,9,5,6,8,7,4,0]                        //call MaxHeapify(A,5) and return max = 15\
max = 15\
\
The operations finish with the result removing the root element from the heap and return its value(in the example, the root element has the value 15)\
\
\pard\pardeftab720\pardirnatural\qj\partightenfactor0

\f2\i\b \cf0 Problem 4. 
\f3\b0 (50 points)
\f2\b  
\f1\i0\b0 Write a program implementing 
\f0\b HeapBottomUp (A) 
\f1\b0 algorithm. Upload your source code. Show your input array and the output heap in the space below.\
\pard\pardeftab720\pardirnatural\qj\partightenfactor0
\cf2 \
Implement Heap Bottom Up algorithm in C programing language\
To run this program, open terminal and change the directory to the folder where you saved this file\
Run the following command line\
        gcc -o heap.o heap.c\
        ./heap.o\
\
Input: First input is the number of element in the array, then input each element in the array respectively\
Output: The heap using HeapBottomUp algorithm\
\
For example:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural\partightenfactor0

\f4 \cf0 {{\NeXTGraphic Screen Shot 2019-06-19 at 1.06.18 PM.png \width13640 \height9540 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}}